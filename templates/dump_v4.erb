# generated by mighq/iptables puppet module, do not edit manually
<%-
#require 'pp'
#STDERR.puts PP.pp(@data, "")

# TODO: ! support for unmanaged builtin chains

# TODO:
# * do not generate chains, which are empty and not referenced
#   support param to force even empty chains
# * not sure, if it is doable
# * refactor this TPL: first validate & process data, then write the output
-%>
<%-
fwdata = @data['v4']

tables = fwdata.keys.sort
tables.each { |table|
-%>
*<%= table %>
<%-
chains = fwdata[table].keys.sort
chains.each { |chain|
  chdata = fwdata[table][chain]

  # check, if chain was defined by resource, or just created by adding rules
  if not chdata.has_key? 'defined' then
    raise sprintf "You did not define chain '%s:%s' with iptables::chain::*. Cannot add rules to non-existent chain.", table, chain
  end

  # only write header of the chain (declare), if it is really filled with something, it could be (unmanaged) or it is builtin
  if (chdata['type'] == 'open' and chdata['rules'].length > 0) or (chdata['type'] != 'open') or (chdata['policy'] != 'undef')
-%>
:<%= chain %> <% if chdata['policy'] != 'undef' then %><%= chdata['policy'] %><% else %>-<% end %> [0:0]
<%-
  end
}
-%>
<%-
chains.each { |chain|
  chdata = fwdata[table][chain]

  # prepare & print rules for chain

  if    chdata['type'] == 'open' then
    # rules are in hash (command => comment) format
    rules = chdata['rules']

    # always sort by key, so we get consistent results each run
    rules = rules.sort

    # header
    if chdata['rules'].length > 0 then
-%>
<%=   sprintf "### rules for '%s:%s' (open)", table, chain %>
<%-
      if chdata.has_key? 'comment' and chdata['comment'].length > 0 then %><%= "# " + chdata['comment'] + "\n" %><% end
    end

    # print all rules in chain
    rules.each { |rule, comment| -%>
<%=   "# " + comment %>
<%=   "-A " + chain + " " + rule %>
<%-
    }

  elsif chdata['type'] == 'immutable' then
    # check if we did not mix immutable & open
    if chdata.has_key? 'rules' then
      raise sprintf "You are trying to dynamically add %d rule(s) to immutable chain '%s:%s'", chdata['rules'].length, table, chain
    end

    if chdata['jumps'].class == Array
      # just jumps are specified, use them for simplicity

      # validate jump items
      rules = []
      chdata['jumps'].each { |jump|
        # check if jump target is known
        if not chains.include? jump then
          raise sprintf "You are trying to reference non-existing chain '%s' in jump from immutable chain '%s:%s'", jump, table, chain
        end

        # only use jump, if there is anything to evaluate in target chain
        # ignore otherwise
        if \
          (fwdata[table][jump]['type'] == 'open'      and fwdata[table][jump]['rules'].length > 0) \
            or
          (fwdata[table][jump]['type'] == 'immutable' and (fwdata[table][jump]['irules'].length > 0 or fwdata[table][jump]['jumps'].length > 0)) \
            or
          (fwdata[table][jump]['type'] == 'unmanaged') \
        then
          rules.push("-j " + jump)
        end
      }
    elsif chdata['irules'].class == Array
      # specific rules are as an array of commands
      rules = chdata['irules']
    else
      raise "this should be alrady caught in the manifests"
    end

    # header
    if rules.length > 0 then
-%>
<%=   sprintf "### rules for '%s:%s' (immutable)", table, chain %>
<%-
      if chdata.has_key? 'comment' and chdata['comment'].length > 0 then %><%= "# " + chdata['comment'] + "\n" %><% end
    end

    # print all rules in immutable chain
    rules.each { |rule| -%>
<%=   "-A " + chain + " " + rule %>
<%- }
  end
-%>
<%- } -%>
COMMIT
<%- } -%>
